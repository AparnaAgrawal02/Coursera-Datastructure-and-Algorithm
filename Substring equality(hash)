4 Substring equality
Problem Introduction
In this problem, you will use hashing to design an algorithm that is able to preprocess a given string ğ‘ 
to answer any query of the form â€œare these two substrings of ğ‘  equal?â€ efficiently. This, in turn, is a basic
building block in many string processing algorithms.
Problem Description
Input Format. The first line contains a string ğ‘  consisting of small Latin letters. The second line contains
the number of queries ğ‘. Each of the next ğ‘ lines specifies a query by three integers ğ‘, ğ‘, and ğ‘™.
Constraints. 1 â‰¤ |ğ‘ | â‰¤ 500 000. 1 â‰¤ ğ‘ â‰¤ 100 000. 0 â‰¤ ğ‘, ğ‘ â‰¤ |ğ‘ | âˆ’ ğ‘™ (hence the indices ğ‘ and ğ‘ are 0-based).
Output Format. For each query, output â€œYesâ€ if ğ‘ ğ‘ğ‘ ğ‘+1. . .ğ‘ ğ‘+ğ‘™âˆ’1 = ğ‘ ğ‘ğ‘ ğ‘+1. . .ğ‘ ğ‘+ğ‘™âˆ’1 are equal, and â€œNoâ€
otherwise.
Time Limits. C: 1 sec, C++: 1 sec, Java: 2 sec, Python: 10 sec. C#: 1.5 sec, Haskell: 2 sec, JavaScript: 5
sec, Ruby: 5 sec, Scala: 5 sec.
Memory Limit. 512MB.
Sample 1.
Input:
trololo
4
0 0 7
2 4 3
3 5 1
1 3 2
Output:
Yes
Yes
Yes
No
0 0 7 â†’ trololo = trololo
2 4 3 â†’ trololo = trololo
3 5 1 â†’ trololo = trololo
1 3 2 â†’ trololo Ì¸= trololo
What to Do
For a string ğ‘¡ = ğ‘¡0ğ‘¡1 Â· Â· Â·ğ‘¡ğ‘šâˆ’1 of length ğ‘š and an integer ğ‘¥, define a polynomial hash function
ğ»(ğ‘¡) =
ğ‘šâˆ‘ï¸âˆ’1
ğ‘—=0
ğ‘¡ğ‘—ğ‘¥
ğ‘šâˆ’ğ‘—âˆ’1 = ğ‘¡0ğ‘¥
ğ‘šâˆ’1 + ğ‘¡1ğ‘¥
ğ‘šâˆ’2 + Â· Â· Â· + ğ‘¡ğ‘šâˆ’2ğ‘¥ + ğ‘¡ğ‘šâˆ’1 .
Let ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1 be a substring of the given string ğ‘  = ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘›âˆ’1. A nice property of the polynomial hash function ğ» is that ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) can be expressed through ğ»(ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) and
11
ğ»(ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘âˆ’1), i.e., through hash values of two prefixes of ğ‘ :
ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) = ğ‘ ğ‘ğ‘¥
ğ‘™âˆ’1 + ğ‘ ğ‘+1ğ‘¥
ğ‘™âˆ’2 + Â· Â· Â· + ğ‘ ğ‘+ğ‘™âˆ’1 =
= ğ‘ 0ğ‘¥
ğ‘+ğ‘™âˆ’1 + ğ‘ 1ğ‘¥
ğ‘+ğ‘™âˆ’2 + Â· Â· Â· + ğ‘ ğ‘+ğ‘™âˆ’1âˆ’
âˆ’ ğ‘¥
ğ‘™
(ğ‘ 0ğ‘¥
ğ‘âˆ’1 + ğ‘ 1ğ‘¥
ğ‘âˆ’2 + Â· Â· Â· + ğ‘ ğ‘âˆ’1) =
= ğ»(ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) âˆ’ ğ‘¥
ğ‘™ğ»(ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘âˆ’1)
This leads us to the following natural idea: we precompute and store the hash values of all prefixes of ğ‘ : let
â„[0] = 0 and, for 1 â‰¤ ğ‘– â‰¤ ğ‘›, let â„[ğ‘–] = ğ»(ğ‘ 0ğ‘ 1 Â· Â· Â· ğ‘ ğ‘–âˆ’1). Then, the identity above becomes
ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) = â„[ğ‘ + ğ‘™] âˆ’ ğ‘¥
ğ‘™â„[ğ‘] .
In other words, we are able to get the hash value of any substring of ğ‘  in just constant time! Clearly, if
ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) Ì¸= ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1), then the corresponding two substrings (ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1 and
ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) are different. However, if the hash values are the same, it is still possible that the substrings
are different â€” this is called a collision. Below, we discuss how to reduce the probability of a collision.
Recall that in practice one never computes the exact value of a polynomial hash function: everything is
computed modulo ğ‘š for some fixed integer ğ‘š. This is done to ensure that all the computations are efficient
and that the hash values are small enough. Recall also that when computing ğ»(ğ‘ ) mod ğ‘š it is important to
take every intermediate step (rather then the final result) modulo ğ‘š.
It can be shown that if ğ‘ 1 and ğ‘ 2 are two different strings of length ğ‘› and ğ‘š is a prime integer, then the
probability that ğ»(ğ‘ 1) mod ğ‘š = ğ»(ğ‘ 2) mod ğ‘š (over the choices of 0 â‰¤ ğ‘¥ â‰¤ ğ‘š âˆ’ 1) is at most ğ‘›
ğ‘š (roughly,
this is because ğ»(ğ‘ 1) âˆ’ ğ»(ğ‘ 2) is a non-zero polynomial of degree at most ğ‘› âˆ’ 1 and hence can have at most
ğ‘› roots modulo ğ‘š). To further reduce the probability of a collision, one may take two different modulus.
Overall, this gives the following approach.
1. Fix ğ‘š1 = 109 + 7 and ğ‘š2 = 109 + 9.
2. Select a random ğ‘¥ from 1 to 109
.
3. Compute arrays â„1[0..ğ‘›] and â„2[0..ğ‘›]: â„1[0] = â„2[0] = 0 and, for 1 â‰¤ ğ‘– â‰¤ ğ‘›, â„1[ğ‘–] = ğ»(ğ‘ 0 Â· Â· Â· ğ‘ ğ‘–âˆ’1) mod
ğ‘š1 and â„2[ğ‘–] = ğ»(ğ‘ 0 Â· Â· Â· ğ‘ ğ‘–âˆ’1) mod ğ‘š2. We illustrate this for â„1 below.
allocate â„1[0..ğ‘›]
â„1[0] â† 0
for ğ‘– from 1 to ğ‘›:
â„1[ğ‘–] â† (ğ‘¥ Â· â„1[ğ‘– âˆ’ 1] + ğ‘ ğ‘–) mod ğ‘š1
4. For every query (ğ‘, ğ‘, ğ‘™):
(a) Use precomputed hash values, to compute the hash values of the substrings ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1 and
ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1 modulo ğ‘š1 and ğ‘š2.
(b) Output â€œYesâ€, if
ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) mod ğ‘š1 = ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) mod ğ‘š1 and
ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) mod ğ‘š2 = ğ»(ğ‘ ğ‘ğ‘ ğ‘+1 Â· Â· Â· ğ‘ ğ‘+ğ‘™âˆ’1) mod ğ‘š2 .
(c) Otherwise, output â€œNoâ€.
Note that, in contrast to Karpâ€“Rabin algorithm, we do not compare the substrings naively when their
hashes coincide. The probability of this event is at most ğ‘›
ğ‘š1
Â·
ğ‘›
ğ‘š2
â‰¤ 10âˆ’9
. (In fact, for random strings the
probability is even much smaller: 10âˆ’18. In this problem, the strings are not random, but the probability of
collision is still very small.)
x=99;# python3

import sys

	
def ask(h1,h2, a, b, l):
	return (h1[a+l]-pow(x,l,m1)*h1[a])%m1==(h1[b+l]-pow(x,l,m1)*h1[b])%m1 and (h2[a+l]-pow(x,l,m2)*h2[a])%m2==(h2[b+l]-pow(x,l,m2)*h2[b])%m2
s = sys.stdin.readline()
q = int(sys.stdin.readline())
m1=10000000007
m2=10000000009
h1=[0]*(len(s)+1)
h2=[0]*(len(s)+1)
for i in range(1,len(s)+1):
    h1[i]=(x*h1[i-1]+ord(s[i-1]))%m1
    h2[i]=(x*h2[i-1]+ord(s[i-1]))%m2

for i in range(q):
	a, b, l = map(int, sys.stdin.readline().split())

    
	print("Yes" if ask(h1,h2,a, b, l) else "No")


